$date
	Fri Jul 14 14:25:09 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test $end
$var wire 16 ! s [15:0] $end
$var wire 1 " cout $end
$var reg 16 # a [15:0] $end
$var reg 16 $ b [15:0] $end
$var reg 1 % cin $end
$scope module dut $end
$var wire 16 & a [15:0] $end
$var wire 16 ' b [15:0] $end
$var wire 1 % cin $end
$var wire 16 ( s [15:0] $end
$var wire 1 " cout $end
$var wire 3 ) c [3:1] $end
$scope module c0 $end
$var wire 4 * a [3:0] $end
$var wire 4 + b [3:0] $end
$var wire 1 % cin $end
$var wire 4 , s [3:0] $end
$var wire 1 - cout $end
$upscope $end
$scope module c1 $end
$var wire 4 . a [3:0] $end
$var wire 4 / b [3:0] $end
$var wire 1 0 cin $end
$var wire 4 1 s [3:0] $end
$var wire 1 2 cout $end
$upscope $end
$scope module c2 $end
$var wire 4 3 a [3:0] $end
$var wire 4 4 b [3:0] $end
$var wire 1 5 cin $end
$var wire 4 6 s [3:0] $end
$var wire 1 7 cout $end
$upscope $end
$scope module c3 $end
$var wire 4 8 a [3:0] $end
$var wire 4 9 b [3:0] $end
$var wire 1 : cin $end
$var wire 4 ; s [3:0] $end
$var wire 1 " cout $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 ;
1:
b0 9
b1111 8
17
b1100 6
15
b1100 4
b1111 3
12
b100 1
10
b100 /
b1111 .
1-
b100 ,
b101 +
b1111 *
b111 )
b110001000100 (
b110001000101 '
b1111111111111111 &
0%
b110001000101 $
b1111111111111111 #
1"
b110001000100 !
$end
#5
00
05
0-
b1100 1
b100 )
02
b101 6
b10111000111 !
b10111000111 (
b111 ,
b11 +
b1000 /
b1001 4
b11 *
b100 .
b1100 3
1%
b100110000011 $
b100110000011 '
b1111110001000011 #
b1111110001000011 &
#15
